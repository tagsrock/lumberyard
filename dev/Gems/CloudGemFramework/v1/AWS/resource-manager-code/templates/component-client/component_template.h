/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
// THIS CODE IS AUTOGENERATED, DO NOT MODIFY
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

#pragma once
#include <AzCore/Component/Component.h>
#include <AzCore/Component/Entity.h>
#include <AzCore/Component/ComponentBus.h>
#include <AzCore/EBus/EBus.h>
#include <AzCore/Memory/SystemAllocator.h>
#include <AzCore/RTTI/BehaviorContext.h>
#include <AzCore/Serialization/EditContext.h>
#include <AzCore/Serialization/SerializeContext.h>
#include <AzCore/std/smart_ptr/make_shared.h>
#include <AzCore/std/smart_ptr/shared_ptr.h>
#include <AzCore/std/string/conversions.h>

#if defined (PLATFORM_SUPPORTS_AWS_NATIVE_SDK)
#include <aws/core/http/HttpRequest.h>
#include <aws/core/http/HttpResponse.h>
#endif // (PLATFORM_SUPPORTS_AWS_NATIVE_SDK)

#include <LmbrAWS/ILmbrAWS.h>

#include <CloudGemFramework/ServiceRequestJob.h>

#include "StdAfx.h"

namespace {{ json_object.namespace }} {
namespace ServiceAPI {
    {% for key, value in json_object.UUIDs.iteritems() %}
    const char* LmbrAWS_CodeGen_{{ key }}_UUID= "{{ value }}";
    {% endfor %}

    // redefs
    {% for item in json_object.redefinitions %}
    using {{ item.name }} = {{ item.primitiveType }};
    {% endfor %}

    bool WriteJson(CloudGemFramework::JsonWriter& writer, const int& item)
    {
        return writer.Int(item);
    }

    bool WriteJson(CloudGemFramework::JsonWriter& writer, const AZStd::string& item)
    {
        return writer.String(item);
    }

    bool WriteJson(CloudGemFramework::JsonWriter& writer, const double& item)
    {
        return writer.Double(item);
    }

    {% for item in json_object.otherClasses %}
    {% if item.isArray %}
    using {{ item.name }} = AZStd::vector<{{ item.elements }}>;

    bool WriteJson(CloudGemFramework::JsonWriter& writer, const {{ item.name }}& list)
    {
        bool ok = true;
        ok = ok && writer.StartArray();
        for (auto item : list)
        {
            ok = ok && WriteJson(writer, item);
        }
        ok = ok && writer.EndArray();
        return ok;
    }
    {% else %}
    struct {{ item.name }}
    {

        AZ_TYPE_INFO({{ item.name }}, LmbrAWS_CodeGen_{{ item.name }}_UUID)
        AZ_CLASS_ALLOCATOR({{ item.name }}, AZ::SystemAllocator, 0)

        {% for prop in item.props %}
        {{ prop.type }} {{prop.name}};
        {% endfor %}

        bool OnJsonKey(const char* key, CloudGemFramework::JsonReader& reader);

        static void Reflect(AZ::ReflectContext* reflection);
    };

    bool WriteJson(CloudGemFramework::JsonWriter& writer, const {{ item.name }}& item)
    {
            bool ok = true;
            ok = ok && writer.StartObject();
            {% for prop in item.props %}
            ok = ok && writer.Key("{{ prop.name }}");
            ok = ok && WriteJson(writer, item.{{ prop.name }});
            {% endfor %}
            ok = ok && writer.EndObject();
            return ok;
    }
    {% endif %}
    {% endfor %}


    // Service RequestJobs
    CLOUD_GEM_SERVICE({{ json_object.namespace }});

    void Configure()
    {
        // Insert any necessary CloudGemFramework configuration here
    }
    {% for path in json_object.functions %}
    class {{ path.functionName}}Request
        : public CloudGemFramework::ServiceRequest
    {
    public:
        SERVICE_REQUEST({{ json_object.namespace }}, HttpMethod::HTTP_{{ path.http_method }}, "{{ path.path }}");

        struct Parameters
        {
            {% for param in path.params %}
            {{ param }};
            {% endfor %}

            bool BuildRequest(CloudGemFramework::RequestBuilder& request)
            {
                bool ok = true;
                {% for param in path.pathParamNames %}
                ok = ok && request.SetPathParameter("{""{{ param }}""}", {{ param }});
                {% endfor %}
                {% for param in path.queryParamNames %}
                ok = ok && request.AddQueryParameter("{{ param }}", {{ param }});
                {% endfor %}
                ok = ok && request.WriteJsonBodyParameter(*this);
                return ok;
            }

            bool WriteJson(CloudGemFramework::JsonWriter& writer) const
            {
                bool ok = true;
                {% for param in path.paramNames %}
                ok = ok && {{ json_object.namespace }}::ServiceAPI::WriteJson(writer, {{ param }});
                {% endfor %}
                return ok;
            }
        };

        {% if path.responseType %}
        {{ path.responseType }} result;
        {% endif %}

        Parameters parameters;
    };


    using {{ path.functionName }}RequestJob = CloudGemFramework::ServiceRequestJob<{{ path.functionName }}Request>;
    {% endfor %}


    // Notification bus for this component
    class {{ json_object.namespace }}Notifications
        : public AZ::ComponentBus
    {
    public:
        // static const bool EnableEventQueue = true;
        {% for function in json_object.functions %}
        /**
         * Sent when the request is a success
         *
         * Params:
         *    jsonOutput:       The output receieved from the lambda call
         *    request:          The AWS Lambda request object
         */
        {% if function.responseType %}
        virtual void On{{ function.functionName }}RequestSuccess(const {{ function.responseType }} response) { }
        {% else %}
        virtual void On{{ function.functionName }}RequestSuccess() { }
        {% endif %}

        /**
         * Sent when the request fails
         *
         * Params:
         *    error:           The output receieved from the lambda call,
         *                     could be function error or an issue with the request
         *    request:         The AWS Lambda request object
         */
        virtual void On{{ function.functionName }}RequestError(const CloudGemFramework::Error error) { }
        {% endfor %}
    };

    using {{ json_object.namespace }}NotificationBus = AZ::EBus<{{ json_object.namespace }}Notifications>;

    class Behavior{{ json_object.namespace }}NotificationBusHandler
        : public {{ json_object.namespace }}NotificationBus::Handler, public AZ::BehaviorEBusHandler
    {
    public:
        AZ_EBUS_BEHAVIOR_BINDER(Behavior{{ json_object.namespace }}NotificationBusHandler, LmbrAWS_CodeGen_NotificationBus1_UUID, AZ::SystemAllocator
        {% for function in json_object.functions %}
        , On{{ function.functionName }}RequestSuccess
        , On{{ function.functionName }}RequestError
        {% endfor %}
        );
        {% for function in json_object.functions %}
        {% if function.responseType %}
        void On{{ function.functionName }}RequestSuccess(const {{ function.responseType }} response) override
        {
            Call(FN_On{{ function.functionName}}RequestSuccess, response);
        }
        {% else %}
        void On{{ function.functionName }}RequestSuccess() override
        {
            Call(FN_On{{ function.functionName}}RequestSuccess);
        }
        {% endif %}
        void On{{ function.functionName }}RequestError(const CloudGemFramework::Error error) override
        {
            Call(FN_On{{ function.functionName }}RequestError, error);
        }
        {% endfor %}
    };
    class {{ json_object.namespace }}ResponseHandler;

    // Request bus for this component
    class {{ json_object.namespace }}Requests
        : public AZ::ComponentBus
    {
    public:
        virtual ~{{ json_object.namespace }}Requests() {}
        {% for function in json_object.functions %}
        {% if function.typedParams %}
        virtual void {{ function.functionName }}({{ function.typedParams}}, {{ json_object.namespace}}ResponseHandler* responseHandler) { }
        {% else %}
        virtual void {{ function.functionName }}({{ json_object.namespace}}ResponseHandler* responseHandler) { }
        {% endif %}
        {% endfor %}
    };

    using {{ json_object.namespace }}RequestBus = AZ::EBus<{{ json_object.namespace }}Requests>;

    // This class is used as a parameter for all requests and throws the response on the {{ json_object.namespace }}NotificationBus
    // Inherit from this to define custom behavior.
    class {{ json_object.namespace }}ResponseHandler
    {
    public:
        AZ_TYPE_INFO({{ json_object.namespace }}ResponseHandler, LmbrAWS_CodeGen_ResponseHandler_UUID)
        AZ_CLASS_ALLOCATOR({{ json_object.namespace }}ResponseHandler, AZ::SystemAllocator, 0)

        virtual ~{{ json_object.namespace }}ResponseHandler() {}
        {% for function in json_object.functions %}
        virtual void Handle{{ function.functionName}}Success({{ function.functionName}}RequestJob* job, AZ::EntityId entityId)
        {
            {% if function.responseType %}
            EBUS_EVENT_ID(entityId, {{ json_object.namespace }}NotificationBus, On{{ function.functionName }}RequestSuccess, job->result);
            {% else %}
            EBUS_EVENT_ID(entityId, {{ json_object.namespace }}NotificationBus, On{{ function.functionName }}RequestSuccess);
            {% endif %}
        }

        virtual void Handle{{ function.functionName}}Error({{ function.functionName}}RequestJob* job, AZ::EntityId entityId)
        {
            EBUS_EVENT_ID(entityId, {{ json_object.namespace }}NotificationBus, On{{ function.functionName }}RequestError, job->error);
        }
        {% endfor %}
    };

    class {{ json_object.componentClass }}
        : public AZ::Component
        , public {{ json_object.namespace }}RequestBus::Handler
    {
    public:
        AZ_COMPONENT({{ json_object.componentClass }}, LmbrAWS_CodeGen_Component_UUID);
        virtual ~{{ json_object.componentClass }}() = default;

        AZStd::shared_ptr<{{ json_object.namespace }}ResponseHandler> m_defaultResponseHandler;

        void Init() override
        {
            m_defaultResponseHandler = AZStd::make_shared<{{ json_object.namespace }}ResponseHandler>();
            {{ json_object.namespace }}::ServiceAPI::Configure();
        }

        void Activate() override
        {
            {{ json_object.namespace }}RequestBus::Handler::BusConnect(m_entity->GetId());
        }

        void Deactivate() override
        {
            {{ json_object.namespace }}RequestBus::Handler::BusDisconnect();
        }

        static void Reflect(AZ::ReflectContext* reflection)
        {
            {% for item in json_object.otherClasses %}
            {% if not item.isArray %}
            {{ item.name }}::Reflect(reflection);
            {% endif %}
            {% endfor %}

            AZ::SerializeContext* serializeContext = azrtti_cast<AZ::SerializeContext*>(reflection);
            if (serializeContext)
            {
                // we must include any fields we want to expose to the editor or lua in the serialize context
                serializeContext->Class<{{ json_object.componentClass }}>()
                    ->Version(1);

                AZ::EditContext* editContext = serializeContext->GetEditContext();
                if (editContext)
                {
                    editContext->Class<{{ json_object.componentClass }}>("{{ json_object.componentClass }}", "{{ json_object.namespace }} Component")
                        ->ClassElement(AZ::Edit::ClassElements::EditorData, "")
                            ->Attribute(AZ::Edit::Attributes::Category, "Cloud Canvas Gems")
                            ->Attribute(AZ::Edit::Attributes::AppearsInAddComponentMenu, AZ_CRC("Game"));
                }
            }

            AZ::BehaviorContext* behaviorContext = azrtti_cast<AZ::BehaviorContext*>(reflection);
            if (behaviorContext)
            {
                behaviorContext->EBus<{{ json_object.namespace }}RequestBus>("{{ json_object.namespace }}RequestBus")
                    // one of these for each function
                    {% for function in json_object.functions %}
                    ->Event("{{ function.functionName }}", &{{ json_object.namespace }}RequestBus::Events::{{ function.functionName }})
                    {% endfor %}
                    ;
                behaviorContext->EBus<{{ json_object.namespace }}NotificationBus>("{{ json_object.namespace }}NotificationBus")
                    ->Handler<Behavior{{ json_object.namespace }}NotificationBusHandler>()
                ;
            }
        }

        // Functions from the swagger definitions
        {% for function in json_object.functions %}
        {% if function.typedParams %}
        void {{ function.functionName }}({{ function.typedParams}}, {{ json_object.namespace}}ResponseHandler* responseHandler) override
        {% else %}
        void {{ function.functionName }}({{ json_object.namespace}}ResponseHandler* responseHandler) override
        {% endif %}
        {
            // Cache our entityId in case the entity goes away
            AZ::EntityId entityId;
            if (m_entity)
            {
                entityId = m_entity->GetId();
            }

            // Cache our default response handler in case this component goes away
            AZStd::shared_ptr < {{ json_object.namespace }}ResponseHandler > defaultResponseHandler = m_defaultResponseHandler;

            // Create job
            {{ function.functionName}}RequestJob* job = {{ function.functionName}}RequestJob::Create(
                [responseHandler, defaultResponseHandler, entityId]({{ function.functionName}}RequestJob* job)
                {
                    // handle success
                    {{ json_object.namespace}}ResponseHandler* successHandler = responseHandler ? responseHandler : defaultResponseHandler.get();
                    if (successHandler)
                    {
                        successHandler->Handle{{ function.functionName }}Success(job, entityId);
                    }
                },
                [responseHandler, defaultResponseHandler, entityId]({{ function.functionName}}RequestJob* job)
                {
                    // handle error
                    {{ json_object.namespace}}ResponseHandler* failureHandler = responseHandler ? responseHandler : defaultResponseHandler.get();
                    if (failureHandler)
                    {
                        failureHandler->Handle{{ function.functionName }}Error(job, entityId);
                    }
                }
            );
            {% for param in function.paramNames %}
            job->parameters.{{ param }} = {{ param }};
            {% endfor %}
            {% for param in function.pathParamNames %}
            job->parameters.{{ param }} = {{ param }};
            {% endfor %}
            {% for param in function.queryParamNames %}
            job->parameters.{{ param }} = {{ param }};
            {% endfor %}
            job->Start();
        }
        {% endfor %}

    };

    {% for item in json_object.otherClasses %}
    {% if not item.isArray %}
    bool {{ item.name }}::OnJsonKey(const char* key, CloudGemFramework::JsonReader& reader)
    {
        {% for prop in item.props %}
        if (strcmp(key, "{{prop.name}}") == 0) return reader.Accept({{ prop.name }});
        {% endfor %}
        return reader.Ignore();
    }

    void {{ item.name }}::Reflect(AZ::ReflectContext* reflection)
    {
        AZ::SerializeContext* serializeContext = azrtti_cast<AZ::SerializeContext*>(reflection);

        if (serializeContext)
        {
            serializeContext->Class<{{ item.name }}>()
                ->Version(1);
        }

        AZ::BehaviorContext* behaviorContext = azrtti_cast<AZ::BehaviorContext*>(reflection);
        if (behaviorContext)
        {
            behaviorContext->Class<{{ item.name }}>("{{ json_object.namespace }}_{{ item.name }}")
                ->Attribute(AZ::Script::Attributes::Storage, AZ::Script::Attributes::StorageType::Value)
            {% for prop in item.props %}
                ->Property("{{ prop.name }}", BehaviorValueProperty(&{{ item.name }}::{{ prop.name }}))
            {% endfor %}
            ;
        }
    }
    {% endif %}
    {% endfor %}
} // ServiceAPI
} // {{ json_object.namespace }}
